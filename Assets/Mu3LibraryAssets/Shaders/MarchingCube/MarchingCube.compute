#pragma kernel CSMain

#define TableCornerLength 8
#define TableEdgeLengthY 12
#define TableEdgeLengthX 2
#define TableTriangleLengthY 256
#define TableTriangleLengthX 16

// 'MarchingTable.cs'를 기반으로 한 데이터
StructuredBuffer<uint3> TableCorners;         // MarchingTable.Corners
StructuredBuffer<uint> TableEdges;           // MarchingTable.Edges
StructuredBuffer<uint> TableTriangles;       // MarchingTable.Triangles

int CubeWidth = -1;
int CubeHeight = -1;
int CubeDepth = -1;
int PointCountWidth = -1;                   // CubeWidth + 1
int PointCountHeight = -1;                  // CubeHeight + 1
int PointCountDepth = -1;                   // CubeDepth + 1

float PointThreshold = 0.1;

StructuredBuffer<float> PointHeights;       // 'MarchingCubeGeneratorWithCS.cs'에서 point의 height값을 받아옴
RWStructuredBuffer<float3> Vertices;        // Mesh 생성에 사용할 vertices 배열
RWStructuredBuffer<int> VerticesCount;      // 각 Cube에 사용된 vertex의 개수

RWStructuredBuffer<float> FloatDebugBuffer; // 디버그용 Float 버퍼



uint GetPointIdx(uint3 id, uint offsetX, uint offsetY, uint offsetZ)
{
    uint3 newID = id + uint3(offsetX, offsetY, offsetZ);
    return (newID.z * PointCountHeight * PointCountWidth) + (newID.y * PointCountWidth) + newID.x;
}

uint GetCubeIdx(uint3 id, uint offsetX, uint offsetY, uint offsetZ)
{
    uint3 newID = id + uint3(offsetX, offsetY, offsetZ);
    return (newID.z * CubeHeight * CubeWidth) + (newID.y * CubeWidth) + newID.x;
}

float3 InterpolateVertex(float3 startPoint, float3 endPoint, float startHeight, float endHeight)
{
    // height 값이 같으면
    if (startHeight == endHeight)
        return (startPoint + endPoint) * 0.5f; // 중간 점 반환

    // threshold가 height와 정확히 일치하는 경우
    if (PointThreshold == startHeight)
        return startPoint;
    if (PointThreshold == endHeight)
        return endPoint;

    // 선형 보간 계산
    float t = (PointThreshold - startHeight) / (endHeight - startHeight);
    return lerp(startPoint, endPoint, t); // Lerp를 활용해 보간
}

[numthreads(8,8,8)]
void CSMain (uint3 id : SV_DispatchThreadID)
{   
    // id는 point의 index가 넘어온다. (라고 생각하자.)
    if (id.x >= CubeWidth || id.y >= CubeHeight || id.z >= CubeDepth)
    {
        return;
    }
    
    uint cubeIdx = GetCubeIdx(id, 0, 0, 0); // id가 곧 cubeIdx와 같다. 'unit3'이냐 'uint'냐의 차이.
    uint cornersIdx[] =
    {
        GetPointIdx(id, 0, 0, 0),
        GetPointIdx(id, 1, 0, 0),
        GetPointIdx(id, 1, 1, 0),
        GetPointIdx(id, 0, 1, 0),
                                
        GetPointIdx(id, 0, 0, 1),
        GetPointIdx(id, 1, 0, 1),
        GetPointIdx(id, 1, 1, 1),
        GetPointIdx(id, 0, 1, 1)
    };
    
    // MarchingTable.Triangles의 Index값 계산
    int configIndex = 0;
    for (int i = 0; i < TableCornerLength; i++)
    {
        if (PointHeights[cornersIdx[i]] >= PointThreshold)
        {
            configIndex |= 1 << i;
        }
    }
    
    // MarchingTable.Triangles의 처음과 끝의 값은 아무것도 그리지 않으므로 패스.
    if (configIndex < 0 || configIndex > TableTriangleLengthY - 1) 
    {
        return;
    }
    
    int triangleStartIdx = TableTriangleLengthX * configIndex;
    int vertCount = 0;
    for (int t = 0; t < TableTriangleLengthX; t++) 
    {
        uint edgeIdx = TableTriangles[triangleStartIdx + t];
        if (edgeIdx == -1)
        {
            break;
        }
        
        uint edgeStartCornerIdx = edgeIdx * TableEdgeLengthX + 0;
        uint edgeEndCornerIdx = edgeIdx * TableEdgeLengthX + 1;
        
        uint cornerStartIdx = TableEdges[edgeStartCornerIdx];
        uint cornerEndIdx = TableEdges[edgeEndCornerIdx];
        
        float3 vertStartPos = id + TableCorners[cornerStartIdx];
        float3 vertEndPos = id + TableCorners[cornerEndIdx];
        
        uint pointStartIdx = cornersIdx[cornerStartIdx];
        uint pointEndIdx = cornersIdx[cornerEndIdx];
        
        float vertStartHeight = PointHeights[pointStartIdx];
        float vertEndHeight = PointHeights[pointEndIdx];
        
        float3 vertex = InterpolateVertex(vertStartPos, vertEndPos, vertStartHeight, vertEndHeight);
    
        Vertices[cubeIdx * TableTriangleLengthX + t] = vertex;
        vertCount++;
    }
    
    VerticesCount[cubeIdx] = vertCount;
    //if (id.x == 0 && id.y == 0 && id.z == 0)
    //{
    //    for (int i = 0; i < 8; i++)
    //    {
    //        FloatDebugBuffer[i] = TableCorners[2].y;
    //    }
    //}
    // FloatDebugBuffer[cubeIdx] = 9999;

}
